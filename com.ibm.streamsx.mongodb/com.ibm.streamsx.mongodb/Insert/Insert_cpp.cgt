<%SPL::CodeGen::implementationPrologue($model);%>

<%
	use File::Basename qw(dirname);
	use InsertCommon;
	
	unshift @INC, dirname($model->getContext()->getOperatorDirectory()) . '/Common';
	require BSONCommon;

	my $dbHost = $model->getParameterByName('dbHost')->getValueAt(0)->getCppExpression();
	my $dbPort = ($_ = $model->getParameterByName('dbPort')) ? $_->getValueAt(0)->getCppExpression() : 27017;
	my $timeout = ($_ = $model->getParameterByName('timeout')) ? $_->getValueAt(0)->getCppExpression() : 0.0;
	my $profiling = ($_ = $model->getParameterByName('profiling')) ? $_->getValueAt(0)->getSPLExpression() : 'off';
	my $autoReconnect = ($_ = $model->getParameterByName('autoReconnect')) ? $_->getValueAt(0)->getCppExpression() : 'true';
%>

string MY_OPERATOR::buildConnUrl(const string& dbHost, uint32_t dbPort) {
	string connUrl = dbHost;
	connUrl += ":"; 
	connUrl += spl_cast<rstring,uint32_t>::cast(dbPort);
	return connUrl;
}

string MY_OPERATOR::buildDbCollection(const string& db, const string& collection) {
	string dbCollection(db);
	dbCollection += ".";
	dbCollection += collection;
	return dbCollection;
}

MY_OPERATOR::MY_OPERATOR() : nInsertsMetric_(getContext().getMetrics().getCustomMetricByName("nInserts")) {

	if(!MongoInit<void>::status_.isOK()) {
		THROW(SPL::SPLRuntimeOperator, "MongoDB initialization failed");
	}
}

MY_OPERATOR::~MY_OPERATOR() {}

void MY_OPERATOR::allPortsReady() {

	try {
		DBClientConnection conn;
		conn.connect(buildConnUrl(<%=$dbHost%>, <%=$dbPort%>));
	}
	catch( const DBException &e ) {
		if (<%=$autoReconnect%>)
			SPLAPPLOG(L_ERROR, e.what(), "MongoDB Connect");
		else
			THROW(SPL::SPLRuntimeOperator, e.what());
	}
}

void MY_OPERATOR::prepareToShutdown() {
	client::shutdown();
}

void MY_OPERATOR::process(Tuple const & tuple, uint32_t port) {
	<%
	my $numberOfInputPorts = $model->getNumberOfInputPorts();
	for (my $i = 0; $i < $numberOfInputPorts; $i++) {%>
	  IPort<%=$i%>Type const & <%=$model->getInputPortAt($i)->getCppTupleName()%> = static_cast<IPort<%=$i%>Type const&>(tuple);
	<%}%>
	streams_boost::shared_ptr<OPort0Type> otuplePtr;
	bool errorFound = false;

<%# [----- perl code -----]
	foreach my $attribute (@{$model->getOutputPortAt(0)->getAttributes()}) {
	  my $name = $attribute->getName();
	  if ($attribute->hasAssignmentWithOutputFunction()) {
		  my $operation = $attribute->getAssignmentOutputFunctionName();
		  if ($operation eq 'AsIs') {
			my $init = $attribute->getAssignmentOutputFunctionParameterValueAt(0)->getCppExpression();
		  %>
			otuplePtr->set_<%=$name%>(<%=$init%>);
		  <%}
		  else {
			my $numberOfParams = @{$attribute->getAssignmentOutputFunctionParameterValues};
			my $expr;
			my $key = '';
			my $keyAssigned = $numberOfParams > 3;
			if ($keyAssigned) {
				$key = $attribute->getAssignmentOutputFunctionParameterValueAt(2)->getCppExpression();
				$expr = $attribute->getAssignmentOutputFunctionParameterValueAt(3);
			}
			else {
				$expr = $attribute->getAssignmentOutputFunctionParameterValueAt(2);
				if (InsertCommon::keyLess($expr->getSPLType())) {
					SPL::CodeGen::errorln("The type '%s' of the expression '%s' requires additional key parameter.", $expr->getSPLType(), $expr->getSPLExpression(), $expr->getSourceLocation());
				}
			}
			my $exprLocation = $expr->getSourceLocation();
			my $cppExpr = $expr->getCppExpression();
			my $splType = $expr->getSPLType();
			
			if ($numberOfInputPorts > 1 && $expr->hasStreamAttributes()) {
				my $portNumber = -1;
				for (my $i = 0; $i < $numberOfInputPorts; $i++) {
					if (index($cppExpr, $model->getInputPortAt($i)->getCppTupleName()) != -1) {
						if ($portNumber != -1) {
							SPL::CodeGen::errorln("Multiple input ports attributes in expression '%s' are used.", $expr->getSPLExpression(), $expr->getSourceLocation());
						}
						else {
							$portNumber = $i;
						}
					}
				}%>
		if(port == <%=$portNumber%>)
			<%}%>
		{
		
<%# [----- perl code -----]
			InsertCommon::buildBSONObjectWithKey($exprLocation, $key, $cppExpr, $splType);
			
			my $db = $attribute->getAssignmentOutputFunctionParameterValueAt(0)->getCppExpression();
			my $collection = $attribute->getAssignmentOutputFunctionParameterValueAt(1)->getCppExpression();
# [----- perl code -----]%>
			
			DBClientConnection * connPtr = getDBClientConnection(<%=$dbHost%>, <%=$dbPort%>);
			
			if(connPtr->isFailed()) {
				if (<%=$autoReconnect%>) {
					SPLAPPLOG(L_ERROR, "Trying to reconnect to " << <%=$dbHost%> << ":" << <%=$dbPort%>, "MongoDB Connect");
					connPtr->isStillConnected();
				}
				else {
					THROW(SPL::SPLRuntimeOperator, "Connection to " << <%=$dbHost%> << ":" << <%=$dbPort%> << " aborted");
				}
			}
				
			<%if ($profiling eq 'slow') {%>
				connPtr->setDbProfilingLevel(<%=$db%>,  ProfileSlow);
			<%} elsif ($profiling eq 'all') {%>
				connPtr->setDbProfilingLevel(<%=$db%>,  ProfileAll);
			<%}%>
			
			connPtr->insert(buildDbCollection(<%=$db%>, <%=$collection%>), b0.obj());
			const string & errorMsg = connPtr->getLastError();
			
			if (errorMsg == "") {
				nInsertsMetric_.incrementValue();
			}
			else {				
				errorFound = true;
				SPLAPPLOG(L_ERROR, errorMsg, "MongoDB Insert");
				if(!otuplePtr){
					otuplePtr = streams_boost::shared_ptr<OPort0Type>(new OPort0Type());
				}
				otuplePtr->set_<%=$name%>(errorMsg);
			}
		}
		  <%}
	  }
	}%>
	if(errorFound) submit(*otuplePtr, 0);
}

// static thread_specific_ptr initialization
streams_boost::thread_specific_ptr<DBClientConnection> MY_OPERATOR::connPtr_;

DBClientConnection * MY_OPERATOR::getDBClientConnection(const string& dbHost, uint32_t dbPort) {
	DBClientConnection * connPtr = connPtr_.get();
	if(!connPtr) {
		connPtr_.reset(new DBClientConnection(<%=$autoReconnect%>, 0, (double)<%=$timeout%>));
		connPtr = connPtr_.get();

		try {
			connPtr->connect(buildConnUrl(dbHost, dbPort));
		}
		catch( const DBException &e ) {
			if (<%=$autoReconnect%>)
				SPLAPPLOG(L_ERROR, e.what(), "MongoDB Connect");
			else
				THROW(SPL::SPLRuntimeOperator, e.what());
		}
	}
	return connPtr;
}

<%SPL::CodeGen::implementationEpilogue($model);%>
