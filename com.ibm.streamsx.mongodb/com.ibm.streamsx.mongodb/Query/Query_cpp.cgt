<%SPL::CodeGen::implementationPrologue($model);%>

<%
	use QueryCommon;

	my $db = $model->getParameterByName('dbName')->getValueAt(0)->getCppExpression();
	my $collection = $model->getParameterByName('collection')->getValueAt(0)->getCppExpression();

	my $dbHost = $model->getParameterByName('dbHost')->getValueAt(0)->getCppExpression();

	my $dbPortParam = $model->getParameterByName('dbPort');
	my $dbPort = (defined $dbPortParam) ? $dbPortParam->getValueAt(0)->getCppExpression() : 27017;

	my $findFieldsParam = $model->getParameterByName('findFields');
	my $findFields = (defined $findFieldsParam) ? '&'.$findFieldsParam->getValueAt(0)->getCppExpression() : 'NULL';

	my $findQueryParam = $model->getParameterByName('findQuery');
	my $findQueryExpr = $findQueryParam->getValueAt(0);
	my $findQuery = (defined $findQueryParam) ? $findQueryExpr->getCppExpression() : 'BSONObj()';
	SPL::CodeGen::errorln("The type '%s' of findQuery parameter is not map or tuple.",
			$findQueryExpr->getSPLType(), $findQueryExpr->getSourceLocation())
			if (defined $findQueryParam && QueryCommon::keyLess($findQueryExpr->getSPLType()));

	my $timeoutParam = $model->getParameterByName('timeout');
	my $timeout = (defined $timeoutParam) ? $timeoutParam->getValueAt(0)->getCppExpression() : 0.0;

	my $ignoreDocumentIdParam = $model->getParameterByName('ignoreDocumentId');
	my $ignoreDocumentId = (defined $ignoreDocumentIdParam) ? $ignoreDocumentIdParam->getValueAt(0)->getCppExpression() : 'true';

	my $inputPort = $model->getInputPortAt(0);
	my $outputPort = $model->getOutputPortAt(0);
	my $inTuple = $inputPort->getCppTupleName();
%>

string MY_OPERATOR::buildConnUrl(const string& dbHost, uint32_t dbPort) {
	string connUrl = dbHost;
	connUrl += ":"; 
	connUrl += spl_cast<rstring,uint32_t>::cast(dbPort);
	return connUrl;
}

string MY_OPERATOR::buildDbCollection(const string& db, const string& collection) {
	string dbCollection(db);
	dbCollection += ".";
	dbCollection += collection;
	return dbCollection;
}

BSONObj MY_OPERATOR::buildFindQueryBO() {
<%if (defined $findQueryParam) {
	QueryCommon::buildBSONObject($model, $findQueryExpr->getSourceLocation(), $findQueryExpr->getCppExpression(), $findQueryExpr->getSPLType(), 0);%>
	return b0.obj();
<%}
  else {%>
	return BSONObj();
<%}%>
}

MY_OPERATOR::MY_OPERATOR() : findQueryBO_(buildFindQueryBO()) {
	try {
		ScopedDbConnection conn(buildConnUrl(<%=$dbHost%>, <%=$dbPort%>), (double)<%=$timeout%>);
		if(!conn.ok()) {
			THROW(SPL::SPLRuntimeOperator, "MongoDB create connection failed");
		}
		conn.done();
	}
	catch( const DBException &e ) {
		THROW(SPL::SPLRuntimeOperator, e.what());
	}
}

MY_OPERATOR::~MY_OPERATOR() {}

void MY_OPERATOR::allPortsReady() {}
void MY_OPERATOR::prepareToShutdown() {}

void MY_OPERATOR::process(Tuple const & tuple, uint32_t port) {
	<%for (my $i = 0; $i < $model->getNumberOfInputPorts(); $i++) {%>
	  IPort<%=$i%>Type const & <%=$model->getInputPortAt($i)->getCppTupleName()%> = static_cast<IPort<%=$i%>Type const&>(tuple);
	<%}%>
	OPort0Type * otuplePtr = getOutputTuple();
	
	<%foreach my $attribute (@{$outputPort->getAttributes()}) {
	  my $attrName = $attribute->getName();
	  if ($attribute->hasAssignmentWithOutputFunction()) {
	  	if ($attribute->getAssignmentOutputFunctionName() eq 'AsIs') {
			my $assign = $attribute->getAssignmentOutputFunctionParameterValueAt(0)->getCppExpression();%>
			otuplePtr->set_<%=$attrName%>(<%=$assign%>);
		<%}
	  }
	  elsif ($attribute->hasAssignment()) {
			my $assign = $attribute->getAssignmentValue()->getCppExpression();%>
			otuplePtr->set_<%=$attrName%>(<%=$assign%>);
	  <%}
	}%>

	streams_boost::scoped_ptr<ScopedDbConnection> conn;
	BSONObj queryResultBO;
	bool docFound = false;
	
	rstring errorMsg = "";
	try {
		conn.reset(new ScopedDbConnection(buildConnUrl(<%=$dbHost%>, <%=$dbPort%>), (double)<%=$timeout%>));

		if(!conn->ok()) {
			errorMsg = "MongoDB create connection failed";
		}
	}
	catch( const DBException &e ) {
		errorMsg = e.what();
	}

	if (errorMsg != "") {
		SPLAPPLOG(L_ERROR, error, "MongoDB Query");
	}

	if(conn->ok()) {
		streams_boost::scoped_ptr<DBClientCursor> cursor((*conn)->query(buildDbCollection(<%=$db%>, <%=$collection%>), <%=$findQuery%>));
		docFound = cursor->more();
		while (cursor->more()) {
			queryResultBO = cursor->next();
			OPort0Type otuple(*otuplePtr);

<%# [----- perl code -----]
		foreach my $attribute (@{$outputPort->getAttributes()}) {
			my $attrName = $attribute->getName();
			if ($attribute->hasAssignmentWithOutputFunction() && ($attribute->getAssignmentOutputFunctionName() ne 'AsIs')) {
				my $numberOfParams = @{$attribute->getAssignmentOutputFunctionParameterValues};
				my $exprLocation = $attribute->getAssignmentSourceLocation();
				my $cppType = $attribute->getCppType();
				my $splType = $attribute->getSPLType();
				if ($numberOfParams > 0) {
					my $findExpr = $attribute->getAssignmentOutputFunctionParameterValueAt(0);
					my $findExprLocation = $findExpr->getSourceLocation();
					my $findCppExpr = $findExpr->getCppExpression();
					my $findSplType = $findExpr->getSPLType();
				}

				QueryCommon::initBSONObject($attrName, $cppType);

				QueryCommon::handleBSONObject($exprLocation, $attrName, $splType, 0);

				QueryCommon::endBSONObject();
			}
		}
# [----- perl code -----]%>

			submit(otuple, 0);
		}
		conn->done();
	}

	if(!docFound) submit(*otuplePtr, 0);
}

streams_boost::thread_specific_ptr<MY_OPERATOR::OPort0Type> MY_OPERATOR::otuplePtr_;

MY_OPERATOR::OPort0Type * MY_OPERATOR::getOutputTuple() {
	OPort0Type * otuplePtr = otuplePtr_.get();
	if(!otuplePtr) {
		otuplePtr_.reset(new OPort0Type());
		otuplePtr = otuplePtr_.get();
	}
	return otuplePtr;
}

<%SPL::CodeGen::implementationEpilogue($model);%>
